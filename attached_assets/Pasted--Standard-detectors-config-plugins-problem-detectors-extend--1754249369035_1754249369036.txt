# Standard detectors
        config['plugins']['problem_detectors'].extend([
            {
                'name': 'threshold_detector',
                'config': {
                    'thresholds': {
                        'cpu_usage': {'warning': 80, 'critical': 95},
                        'memory_usage': {'warning': 85, 'critical': 95},
                        'mcp_response_time': {'warning': 2.0, 'critical': 5.0},
                        'mcp_error_rate': {'warning': 0.05, 'critical': 0.1}
                    }
                }
            },
            {
                'name': 'mcp_pattern_detector',
                'config': {
                    'server_patterns': {
                        server_id: {
                            'expected_patterns': ['startup', 'request_processed', 'tool_executed'],
                            'error_patterns': ['error', 'exception', 'timeout', 'failed']
                        } for server_id in config['mcp_servers'].keys()
                    }
                }
            }
        ])
        
        # Code analysis detector (if source directories available)
        if config['code_analysis']['source_directories']:
            config['plugins']['problem_detectors'].append({
                'name': 'code_analysis_detector',
                'config': {
                    'source_directories': config['code_analysis']['source_directories'],
                    'confidence_threshold': 0.7
                }
            })
        
        # Standard remediators
        config['plugins']['remediators'].extend([
            {
                'name': 'system_remediation',
                'config': {
                    'allowed_actions': ['clear_cache', 'log_rotation', 'process_restart']
                }
            },
            {
                'name': 'mcp_server_remediation',
                'config': {
                    'servers': config['mcp_servers'],
                    'restart_strategies': {
                        'process': 'kill_and_restart',
                        'container': 'docker_restart',
                        'service': 'systemctl_restart'
                    }
                }
            }
        ])

# ============================================================================
# MCP-SPECIFIC METRICS COLLECTOR
# ============================================================================

class MCPMetricsCollectorPlugin:
    """Spezieller Metrics Collector für MCP Server"""
    
    def __init__(self, discovered_servers: List[MCPServerInfo]):
        self.servers = {server.server_id: server for server in discovered_servers}
        
    @property
    def name(self) -> str:
        return "mcp_metrics_collector"
    
    @property
    def version(self) -> str:
        return "1.0.0"
    
    async def initialize(self, config: Dict[str, Any]) -> bool:
        logger.info(f"Initialized MCP metrics collector for {len(self.servers)} servers")
        return True
    
    async def cleanup(self) -> None:
        pass
    
    async def collect_metrics(self) -> Dict[str, Any]:
        """Sammelt MCP-spezifische Metriken von allen Servern"""
        
        metrics = {
            'mcp_total_servers': len(self.servers),
            'mcp_running_servers': 0,
            'mcp_stopped_servers': 0,
            'mcp_unknown_servers': 0
        }
        
        for server_id, server in self.servers.items():
            try:
                server_metrics = await self._collect_server_metrics(server)
                
                # Prefix metrics with server ID
                for key, value in server_metrics.items():
                    metrics[f"mcp_{server_id}_{key}"] = value
                
                # Count server states
                if server_metrics.get('status') == 'running':
                    metrics['mcp_running_servers'] += 1
                elif server_metrics.get('status') == 'stopped':
                    metrics['mcp_stopped_servers'] += 1
                else:
                    metrics['mcp_unknown_servers'] += 1
                    
            except Exception as e:
                logger.error(f"Error collecting metrics for server {server_id}: {e}")
                metrics[f"mcp_{server_id}_status"] = 'error'
                metrics[f"mcp_{server_id}_error"] = str(e)
        
        return metrics
    
    async def _collect_server_metrics(self, server: MCPServerInfo) -> Dict[str, Any]:
        """Sammelt Metriken für einzelnen MCP Server"""
        
        metrics = {
            'status': 'unknown',
            'response_time': 0.0,
            'uptime': 0,
            'request_count': 0,
            'error_count': 0
        }
        
        # Test server availability
        start_time = time.time()
        is_alive = await self._test_server_alive(server)
        response_time = time.time() - start_time
        
        metrics['status'] = 'running' if is_alive else 'stopped'
        metrics['response_time'] = response_time
        
        if is_alive:
            # Collect detailed metrics if server is running
            server_info = await self._get_server_metrics(server)
            if server_info:
                metrics.update(server_info)
        
        # Collect process-level metrics if available
        if server.pid:
            process_metrics = await self._get_process_metrics(server.pid)
            metrics.update(process_metrics)
        
        return metrics
    
    async def _test_server_alive(self, server: MCPServerInfo) -> bool:
        """Testet ob Server erreichbar ist"""
        
        try:
            if server.protocol == 'http':
                async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=5)) as session:
                    health_url = f"http://{server.host}:{server.port}{server.health_endpoint or '/health'}"
                    async with session.get(health_url) as response:
                        return response.status < 500
            elif server.protocol == 'websocket':
                import websockets
                ws_url = f"ws://{server.host}:{server.port}/"
                async with websockets.connect(ws_url, timeout=5):
                    return True
            else:
                # TCP connection test
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((server.host, server.port))
                sock.close()
                return result == 0
                
        except Exception:
            return False
    
    async def _get_server_metrics(self, server: MCPServerInfo) -> Dict[str, Any]:
        """Holt detaillierte Server-Metriken über API"""
        
        metrics = {}
        
        try:
            if server.protocol == 'http':
                async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:
                    
                    # Try metrics endpoint
                    if server.metrics_endpoint:
                        metrics_url = f"http://{server.host}:{server.port}{server.metrics_endpoint}"
                        try:
                            async with session.get(metrics_url) as response:
                                if response.status == 200:
                                    data = await response.json()
                                    metrics.update(data)
                        except:
                            pass
                    
                    # Try health endpoint for additional info
                    if server.health_endpoint:
                        health_url = f"http://{server.host}:{server.port}{server.health_endpoint}"
                        try:
                            async with session.get(health_url) as response:
                                if response.status == 200:
                                    data = await response.json()
                                    metrics.update(data)
                        except:
                            pass
                    
                    # Try common MCP endpoints
                    mcp_endpoints = ['/status', '/info', '/mcp/status']
                    for endpoint in mcp_endpoints:
                        try:
                            async with session.get(f"http://{server.host}:{server.port}{endpoint}") as response:
                                if response.status == 200:
                                    data = await response.json()
                                    metrics.update(data)
                                    break
                        except:
                            continue
                            
        except Exception as e:
            logger.debug(f"Error getting server metrics: {e}")
        
        return metrics
    
    async def _get_process_metrics(self, pid: int) -> Dict[str, Any]:
        """Sammelt Prozess-spezifische Metriken"""
        
        metrics = {}
        
        try:
            process = psutil.Process(pid)
            
            # Basic process info
            metrics['process_cpu_percent'] = process.cpu_percent()
            metrics['process_memory_mb'] = process.memory_info().rss / 1024 / 1024
            metrics['process_threads'] = process.num_threads()
            
            # Process uptime
            create_time = process.create_time()
            metrics['process_uptime'] = time.time() - create_time
            
            # File descriptors (Unix only)
            try:
                metrics['process_open_files'] = process.num_fds()
            except:
                pass
            
            # Network connections
            try:
                connections = process.connections()
                metrics['process_connections'] = len(connections)
                metrics['process_listening_ports'] = len([c for c in connections if c.status == 'LISTEN'])
            except:
                pass
                
        except psutil.NoSuchProcess:
            metrics['process_status'] = 'not_found'
        except Exception as e:
            metrics['process_error'] = str(e)
        
        return metrics

# ============================================================================
# MCP-SPECIFIC PROBLEM DETECTOR
# ============================================================================

class MCPPatternDetectorPlugin:
    """MCP-spezifischer Problem Detector"""
    
    def __init__(self, servers: Dict[str, MCPServerInfo]):
        self.servers = servers
        self.server_patterns = {}
        
    @property
    def name(self) -> str:
        return "mcp_pattern_detector"
    
    @property
    def version(self) -> str:
        return "1.0.0"
    
    async def initialize(self, config: Dict[str, Any]) -> bool:
        self.server_patterns = config.get('server_patterns', {})
        logger.info(f"Initialized MCP pattern detector for {len(self.servers)} servers")
        return True
    
    async def cleanup(self) -> None:
        pass
    
    async def detect_problems(self, metrics: Dict[str, Any], 
                            history: List[Dict[str, Any]]) -> List:
        """Erkennt MCP-spezifische Probleme"""
        
        from framework_prototype import Problem, ProblemSeverity
        problems = []
        
        # Check each server's status
        for server_id, server in self.servers.items():
            server_problems = await self._detect_server_problems(server_id, server, metrics)
            problems.extend(server_problems)
        
        # Check cross-server patterns
        cross_server_problems = await self._detect_cross_server_problems(metrics)
        problems.extend(cross_server_problems)
        
        return problems
    
    async def _detect_server_problems(self, server_id: str, server: MCPServerInfo, 
                                    metrics: Dict[str, Any]) -> List:
        """Erkennt Probleme für einzelnen Server"""
        
        from framework_prototype import Problem, ProblemSeverity
        problems = []
        
        server_prefix = f"mcp_{server_id}_"
        
        # Server down
        status = metrics.get(f"{server_prefix}status")
        if status == 'stopped' or status == 'error':
            problems.append(Problem(
                type=f"mcp_server_down",
                severity=ProblemSeverity.CRITICAL,
                description=f"MCP server {server.name} is not responding",
                timestamp=datetime.now(),
                metadata={
                    'server_id': server_id,
                    'server_name': server.name,
                    'host': server.host,
                    'port': server.port,
                    'last_status': status
                }
            ))
        
        # High response time
        response_time = metrics.get(f"{server_prefix}response_time", 0)
        if response_time > 5.0:  # 5 seconds
            problems.append(Problem(
                type=f"mcp_high_response_time",
                severity=ProblemSeverity.HIGH if response_time > 10 else ProblemSeverity.MEDIUM,
                description=f"MCP server {server.name} has high response time: {response_time:.2f}s",
                timestamp=datetime.now(),
                metadata={
                    'server_id': server_id,
                    'server_name': server.name,
                    'response_time': response_time,
                    'threshold': 5.0
                }
            ))
        
        # High error rate
        error_count = metrics.get(f"{server_prefix}error_count", 0)
        request_count = metrics.get(f"{server_prefix}request_count", 1)
        error_rate = error_count / max(request_count, 1)
        
        if error_rate > 0.1:  # 10% error rate
            problems.append(Problem(
                type=f"mcp_high_error_rate",
                severity=ProblemSeverity.HIGH,
                description=f"MCP server {server.name} has high error rate: {error_rate:.1%}",
                timestamp=datetime.now(),
                metadata={
                    'server_id': server_id,
                    'server_name': server.name,
                    'error_rate': error_rate,
                    'error_count': error_count,
                    'request_count': request_count
                }
            ))
        
        # Memory issues
        memory_mb = metrics.get(f"{server_prefix}process_memory_mb", 0)
        if memory_mb > 1000:  # 1GB
            problems.append(Problem(
                type=f"mcp_high_memory_usage",
                severity=ProblemSeverity.MEDIUM,
                description=f"MCP server {server.name} using high memory: {memory_mb:.0f}MB",
                timestamp=datetime.now(),
                metadata={
                    'server_id': server_id,
                    'server_name': server.name,
                    'memory_mb': memory_mb,
                    'threshold': 1000
                }
            ))
        
        return problems
    
    async def _detect_cross_server_problems(self, metrics: Dict[str, Any]) -> List:
        """Erkennt übergreifende Server-Probleme"""
        
        from framework_prototype import Problem, ProblemSeverity
        problems = []
        
        # Multiple servers down
        running_servers = metrics.get('mcp_running_servers', 0)
        total_servers = metrics.get('mcp_total_servers', 0)
        
        if total_servers > 1 and running_servers < total_servers * 0.5:
            problems.append(Problem(
                type="mcp_multiple_servers_down",
                severity=ProblemSeverity.CRITICAL,
                description=f"Multiple MCP servers down: {running_servers}/{total_servers} running",
                timestamp=datetime.now(),
                metadata={
                    'running_servers': running_servers,
                    'total_servers': total_servers,
                    'availability': running_servers / total_servers if total_servers > 0 else 0
                }
            ))
        
        return problems

# ============================================================================
# MCP-SPECIFIC REMEDIATION
# ============================================================================

class MCPServerRemediationPlugin:
    """MCP-spezifische Problemlösung"""
    
    def __init__(self, servers: Dict[str, MCPServerInfo]):
        self.servers = servers
        self.restart_strategies = {}
        
    @property
    def name(self) -> str:
        return "mcp_server_remediation"
    
    @property
    def version(self) -> str:
        return "1.0.0"
    
    async def initialize(self, config: Dict[str, Any]) -> bool:
        self.restart_strategies = config.get('restart_strategies', {
            'process': 'kill_and_restart',
            'container': 'docker_restart',
            'service': 'systemctl_restart'
        })
        logger.info(f"Initialized MCP server remediation for {len(self.servers)} servers")
        return True
    
    async def cleanup(self) -> None:
        pass
    
    async def can_handle_problem(self, problem) -> bool:
        """Prüft ob Problem MCP-spezifisch ist"""
        return problem.type.startswith('mcp_')
    
    async def execute_remediation(self, problem, context: Dict[str, Any]) -> Dict[str, Any]:
        """Führt MCP-spezifische Problemlösung aus"""
        
        problem_type = problem.type
        server_id = problem.metadata.get('server_id')
        
        if not server_id or server_id not in self.servers:
            return {
                'success': False,
                'message': 'Server not found or not managed',
                'actions_taken': []
            }
        
        server = self.servers[server_id]
        
        try:
            if problem_type == 'mcp_server_down':
                return await self._restart_server(server)
            elif problem_type == 'mcp_high_response_time':
                return await self._optimize_server_performance(server)
            elif problem_type == 'mcp_high_error_rate':
                return await self._fix_server_errors(server)
            elif problem_type == 'mcp_high_memory_usage':
                return await self._reduce_server_memory(server)
            else:
                return await self._generic_server_fix(server, problem_type)
                
        except Exception as e:
            return {
                'success': False,
                'message': f'Remediation failed: {str(e)}',
                'actions_taken': ['remediation_attempted'],
                'error': str(e)
            }
    
    async def _restart_server(self, server: MCPServerInfo) -> Dict[str, Any]:
        """Startet MCP Server neu"""
        
        actions_taken = []
        
        try:
            # Determine restart strategy
            if server.container_id:
                # Docker container restart
                success = await self._restart_docker_container(server)
                actions_taken.append('docker_container_restart')
            elif server.pid:
                # Process restart
                success = await self._restart_process(server)
                actions_taken.append('process_restart')
            else:
                # Try service restart
                success = await self._restart_service(server)
                actions_taken.append('service_restart')
            
            return {
                'success': success,
                'message': f'Server {server.name} restart {"successful" if success else "failed"}',
                'actions_taken': actions_taken
            }
            
        except Exception as e:
            return {
                'success': False,
                'message': f'Restart failed: {str(e)}',
                'actions_taken': actions_taken,
                'error': str(e)
            }
    
    async def _restart_docker_container(self, server: MCPServerInfo) -> bool:
        """Startet Docker Container neu"""
        
        try:
            docker_client = docker.from_env()
            container = docker_client.containers.get(server.container_id)
            
            logger.info(f"Restarting Docker container {server.container_name}")
            container.restart(timeout=30)
            
            # Wait for container to be ready
            await asyncio.sleep(10)
            
            # Verify container is running
            container.reload()
            return container.status == 'running'
            
        except Exception as e:
            logger.error(f"Docker restart failed: {e}")
            return False
    
    async def _restart_process(self, server: MCPServerInfo) -> bool:
        """Startet Prozess neu"""
        
        try:
            # Kill current process
            if server.pid:
                try:
                    process = psutil.Process(server.pid)
                    process.terminate()
                    
                    # Wait for graceful shutdown
                    await asyncio.sleep(5)
                    
                    if process.is_running():
                        process.kill()
                        
                except psutil.NoSuchProcess:
                    pass
            
            # Restart process if we have command line
            if server.command_line:
                # Extract command and arguments
                cmd_parts = server.command_line.split()
                
                # Start new process
                process = subprocess.Popen(
                    cmd_parts,
                    cwd=server.working_directory,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
                
                # Update server info
                server.pid = process.pid
                
                # Wait a bit and check if process is still running
                await asyncio.sleep(5)
                return process.poll() is None
            
            return False
            
        except Exception as e:
            logger.error(f"Process restart failed: {e}")
            return False
    
    async def _restart_service(self, server: MCPServerInfo) -> bool:
        """Startet Service neu"""
        
        try:
            # Try common service names
            service_names = [
                server.name,
                f"mcp-{server.name}",
                f"{server.name}-server",
                "mcp-server"
            ]
            
            for service_name in service_names:
                try:
                    result = subprocess.run(
                        ['sudo', 'systemctl', 'restart', service_name],
                        capture_output=True,
                        text=True,
                        timeout=30
                    )
                    
                    if result.returncode == 0:
                        logger.info(f"Service {service_name} restarted successfully")
                        return True
                        
                except subprocess.TimeoutExpired:
                    continue
                except Exception:
                    continue
            
            return False
            
        except Exception as e:
            logger.error(f"Service restart failed: {e}")
            return False
    
    async def _optimize_server_performance(self, server: MCPServerInfo) -> Dict[str, Any]:
        """Optimiert Server-Performance"""
        
        actions_taken = []
        
        # Clear any caches
        # This would be server-specific implementation
        actions_taken.append('cleared_caches')
        
        # Adjust resource limits if using containers
        if server.container_id:
            # Could adjust CPU/memory limits
            actions_taken.append('adjusted_resource_limits')
        
        return {
            'success': True,
            'message': f'Performance optimization applied to {server.name}',
            'actions_taken': actions_taken
        }
    
    async def _fix_server_errors(self, server: MCPServerInfo) -> Dict[str, Any]:
        """Behebt Server-Fehler"""
        
        actions_taken = []
        
        # Check and rotate log files if they're too large
        if server.log_files:
            for log_file in server.log_files:
                try:
                    log_path = Path(log_file)
                    if log_path.exists() and log_path.stat().st_size > 100 * 1024 * 1024:  # 100MB
                        # Rotate large log file
                        backup_path = log_path.with_suffix(f'.{int(time.time())}.log')
                        log_path.rename(backup_path)
                        log_path.touch()
                        actions_taken.append(f'rotated_log_{log_path.name}')
                except Exception:
                    pass
        
        # Could implement more error-specific fixes here
        actions_taken.append('error_analysis_completed')
        
        return {
            'success': True,
            'message': f'Error fixes applied to {server.name}',
            'actions_taken': actions_taken
        }
    
    async def _reduce_server_memory(self, server: MCPServerInfo) -> Dict[str, Any]:
        """Reduziert Server-Speicherverbrauch"""
        
        actions_taken = []
        
        # Force garbage collection if possible
        # This would require server-specific API calls
        actions_taken.append('triggered_garbage_collection')
        
        # Restart server if memory usage is critical
        if server.pid:
            try:
                process = psutil.Process(server.pid)
                memory_mb = process.memory_info().rss / 1024 / 1024
                
                if memory_mb > 2000:  # 2GB - critical level
                    restart_result = await self._restart_server(server)
                    if restart_result['success']:
                        actions_taken.extend(restart_result['actions_taken'])
                        actions_taken.append('emergency_restart_due_to_memory')
            except Exception:
                pass
        
        return {
            'success': True,
            'message': f'Memory optimization applied to {server.name}',
            'actions_taken': actions_taken
        }
    
    async def _generic_server_fix(self, server: MCPServerInfo, problem_type: str) -> Dict[str, Any]:
        """Generische Server-Problemlösung"""
        
        return {
            'success': True,
            'message': f'Generic fix applied to {server.name} for {problem_type}',
            'actions_taken': ['generic_server_maintenance']
        }

# ============================================================================
# INTEGRATION UND CLI
# ============================================================================

class MCPDiscoveryCLI:
    """CLI für MCP Server Discovery und Konfiguration"""
    
    def __init__(self):
        self.discovery = None
        self.discovered_servers = []
    
    async def run_discovery_wizard(self):
        """Interaktiver Discovery-Wizard"""
        
        print("🔍 MCP Server Discovery Wizard")
        print("=" * 40)
        
        # Configure discovery
        discovery_config = await self._configure_discovery()
        
        # Run discovery
        self.discovery = MCPServerDiscovery(discovery_config)
        print("\n🔎 Scanning for MCP servers...")
        
        self.discovered_servers = await self.discovery.discover_all_servers()
        
        if not self.discovered_servers:
            print("❌ No MCP servers found")
            return
        
        # Show discovered servers
        print(f"\n✅ Found {len(self.discovered_servers)} MCP servers:")
        print("=" * 60)
        
        for i, server in enumerate(self.discovered_servers, 1):
            print(f"\n{i}. {server.name}")
            print(f"   📍 Location: {server.host}:{server.port}")
            print(f"   🔌 Protocol: {server.protocol}")
            print(f"   ⚡ Status: {server.status}")
            print(f"   🔍 Discovery: {server.discovery_method}")
            
            if server.source_directory:
                print(f"   📁 Source: {server.source_directory}")
            
            if server.container_name:
                print(f"   🐳 Container: {server.container_name}")
            
            if server.log_files:
                print(f"   📝 Logs: {len(server.log_files)} files")
        
        # Generate configuration
        choice = input(f"\nGenerate monitoring configuration? (y/n): ").lower()
        if choice.startswith('y'):
            await self._generate_configuration()
    
    async def _configure_discovery(self) -> Dict[str, Any]:
        """Konfiguriert Discovery-Parameter"""
        
        print("\n⚙️ Discovery Configuration:")
        
        # Scan methods
        print("\nAvailable discovery methods:")
        print("1. Process scanning (find running MCP processes)")
        print("2. Port scanning (test common MCP ports)")  
        print("3. Docker scanning (find MCP containers)")
        print("4. Config file scanning (find MCP configs)")
        
        methods_input = input("\nSelect methods (1,2,3,4 or 'all'): ").strip()
        
        if methods_input.lower() == 'all':
            discovery_methods = ['process_scan', 'port_scan', 'docker_scan', 'config_file_scan']
        else:
            method_map = {
                '1': 'process_scan',
                '2': 'port_scan', 
                '3': 'docker_scan',
                '4': 'config_file_scan'
            }
            discovery_methods = [method_map[m] for m in methods_input.split(',') if m in method_map]
        
        # Scan ports
        ports_input = input("\nScan ports (default: 8000,8080,3000,5000): ").strip()
        scan_ports = [8000, 8080, 3000, 5000]
        if ports_input:
            try:
                scan_ports = [int(p.strip()) for p in ports_input.split(',')]
            except ValueError:
                print("Invalid ports, using defaults")
        
        # Scan hosts  
        hosts_input = input("\nScan hosts (default: localhost,127.0.0.1): ").strip()
        scan_hosts = ['localhost', '127.0.0.1']
        if hosts_input:
            scan_hosts = [h.strip() for h in hosts_input.split(',')]
        
        return {
            'discovery_methods': discovery_methods,
            'scan_ports': scan_ports,
            'scan_hosts': scan_hosts
        }
    
    async def _generate_configuration(self):
        """Generiert Monitoring-Konfiguration"""
        
        print("\n📝 Generating monitoring configuration...")
        
        configurator = MCPAutoConfigurator(self.discovered_servers)
        config = await configurator.generate_monitoring_config()
        
        # Save configuration
        config_file = "mcp_auto_config.yaml"
        with open(config_file, 'w') as f:
            yaml.dump(config, f, default_flow_style=False, indent=2)
        
        print(f"✅ Configuration saved: {config_file}")
        
        print(f"\n📊 Configuration Summary:")
        print(f"  🖥️  Servers: {len(config['mcp_servers'])}")
        print(f"  📁 Source Directories: {len(config['code_analysis']['source_directories'])}")
        print(f"  🔌 Plugins: {sum(len(plugins) for plugins in config['plugins'].values())}")
        
        # Option to start monitoring immediately
        start_choice = input(f"\nStart monitoring with this configuration? (y/n): ").lower()
        if start_choice.startswith('y'):
            print("\n🚀 Starting MCP monitoring...")
            # This would integrate with the main framework
            print("Framework would be started here with the generated configuration")

async def main_mcp_discovery():
    """Main entry point for MCP discovery"""
    
    import sys
    
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        
        if command == 'discover':
            cli = MCPDiscoveryCLI()
            await cli.run_discovery_wizard()
        elif command == # mcp_server_discovery.py - MCP Server Discovery und Auto-Konfiguration

import asyncio
import json
import psutil
import subprocess
import docker
import requests
import aiohttp
import yaml
import os
import re
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field, asdict
from datetime import datetime
import logging
import socket
import time
from urllib.parse import urlparse

logger = logging.getLogger(__name__)

@dataclass
class MCPServerInfo:
    """Information über einen entdeckten MCP Server"""
    server_id: str
    name: str
    host: str
    port: int
    protocol: str  # http, https, websocket
    status: str  # running, stopped, unknown
    
    # Process information
    pid: Optional[int] = None
    process_name: Optional[str] = None
    command_line: Optional[str] = None
    working_directory: Optional[str] = None
    
    # Code location
    executable_path: Optional[str] = None
    source_directory: Optional[str] = None
    config_file: Optional[str] = None
    log_files: List[str] = field(default_factory=list)
    
    # Runtime information
    version: Optional[str] = None
    capabilities: List[str] = field(default_factory=list)
    health_endpoint: Optional[str] = None
    metrics_endpoint: Optional[str] = None
    
    # Container information (if containerized)
    container_id: Optional[str] = None
    container_name: Optional[str] = None
    image_name: Optional[str] = None
    
    # Discovery metadata
    discovery_method: str = "unknown"
    discovered_at: datetime = field(default_factory=datetime.now)
    last_seen: datetime = field(default_factory=datetime.now)

class MCPServerDiscovery:
    """Automatische Erkennung von MCP Servern"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.discovered_servers = {}
        self.docker_client = None
        self.scan_ports = config.get('scan_ports', [8000, 8080, 3000, 5000])
        self.scan_hosts = config.get('scan_hosts', ['localhost', '127.0.0.1'])
        self.discovery_methods = config.get('discovery_methods', [
            'process_scan',
            'port_scan', 
            'docker_scan',
            'config_file_scan',
            'service_registry'
        ])
        
        # Initialize Docker client if available
        try:
            self.docker_client = docker.from_env()
        except Exception:
            logger.warning("Docker client not available")
    
    async def discover_all_servers(self) -> List[MCPServerInfo]:
        """Führt vollständige Server-Erkennung aus"""
        
        logger.info("Starting MCP server discovery...")
        discovered = []
        
        # Run all discovery methods
        for method in self.discovery_methods:
            try:
                if method == 'process_scan':
                    servers = await self._discover_by_process_scan()
                elif method == 'port_scan':
                    servers = await self._discover_by_port_scan()
                elif method == 'docker_scan':
                    servers = await self._discover_by_docker_scan()
                elif method == 'config_file_scan':
                    servers = await self._discover_by_config_scan()
                elif method == 'service_registry':
                    servers = await self._discover_by_service_registry()
                else:
                    continue
                
                discovered.extend(servers)
                logger.info(f"Discovery method '{method}' found {len(servers)} servers")
                
            except Exception as e:
                logger.error(f"Error in discovery method '{method}': {e}")
        
        # Deduplicate and merge information
        unique_servers = self._deduplicate_servers(discovered)
        
        # Enhance server information
        for server in unique_servers:
            await self._enhance_server_info(server)
        
        # Update cache
        for server in unique_servers:
            self.discovered_servers[server.server_id] = server
        
        logger.info(f"Total unique MCP servers discovered: {len(unique_servers)}")
        return unique_servers
    
    async def _discover_by_process_scan(self) -> List[MCPServerInfo]:
        """Erkennung durch Prozess-Scanning"""
        
        servers = []
        
        # Common MCP server process patterns
        mcp_patterns = [
            r'.*mcp.*server.*',
            r'.*model.*context.*protocol.*',
            r'.*mcp-server.*',
            r'node.*mcp.*',
            r'python.*mcp.*',
            r'.*claude.*mcp.*'
        ]
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'cwd']):
            try:
                proc_info = proc.info
                cmdline = ' '.join(proc_info['cmdline'] or [])
                
                # Check if process matches MCP patterns
                for pattern in mcp_patterns:
                    if re.search(pattern, cmdline, re.IGNORECASE):
                        server = await self._create_server_from_process(proc, proc_info)
                        if server:
                            servers.append(server)
                        break
                
                # Check for specific MCP server executables
                if proc_info['name'] and any(keyword in proc_info['name'].lower() 
                                           for keyword in ['mcp', 'claude']):
                    server = await self._create_server_from_process(proc, proc_info)
                    if server:
                        servers.append(server)
                        
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        
        return servers
    
    async def _create_server_from_process(self, proc, proc_info: Dict) -> Optional[MCPServerInfo]:
        """Erstellt Server-Info aus Prozess-Information"""
        
        try:
            cmdline = ' '.join(proc_info['cmdline'] or [])
            
            # Extract port from command line
            port_match = re.search(r'--port[=\s](\d+)|:(\d+)', cmdline)
            port = None
            if port_match:
                port = int(port_match.group(1) or port_match.group(2))
            
            # Try to detect port from network connections
            if not port:
                try:
                    connections = proc.connections()
                    for conn in connections:
                        if conn.status == 'LISTEN' and conn.laddr.ip in ['0.0.0.0', '127.0.0.1']:
                            port = conn.laddr.port
                            break
                except:
                    pass
            
            if not port:
                port = 8000  # Default assumption
            
            # Determine server name
            server_name = self._extract_server_name(proc_info['name'], cmdline)
            
            server = MCPServerInfo(
                server_id=f"proc_{proc_info['pid']}",
                name=server_name,
                host='localhost',
                port=port,
                protocol='http',
                status='running',
                pid=proc_info['pid'],
                process_name=proc_info['name'],
                command_line=cmdline,
                working_directory=proc_info['cwd'],
                discovery_method='process_scan'
            )
            
            return server
            
        except Exception as e:
            logger.debug(f"Error creating server from process: {e}")
            return None
    
    def _extract_server_name(self, process_name: str, cmdline: str) -> str:
        """Extrahiert Server-Namen aus Prozess-Informationen"""
        
        # Try to extract from command line arguments
        name_patterns = [
            r'--name[=\s]([^\s]+)',
            r'--server-name[=\s]([^\s]+)',
            r'mcp-server-([^\s]+)',
            r'([^/\s]+)\.js',
            r'([^/\s]+)\.py'
        ]
        
        for pattern in name_patterns:
            match = re.search(pattern, cmdline)
            if match:
                return match.group(1)
        
        # Fallback to process name
        if process_name and process_name != 'python' and process_name != 'node':
            return process_name
        
        return 'unknown-mcp-server'
    
    async def _discover_by_port_scan(self) -> List[MCPServerInfo]:
        """Erkennung durch Port-Scanning"""
        
        servers = []
        
        for host in self.scan_hosts:
            for port in self.scan_ports:
                try:
                    # Test HTTP connection
                    is_http = await self._test_http_endpoint(host, port)
                    if is_http:
                        server_info = await self._probe_http_server(host, port)
                        if server_info and self._is_likely_mcp_server(server_info):
                            server = MCPServerInfo(
                                server_id=f"port_{host}_{port}",
                                name=server_info.get('name', f'server-{port}'),
                                host=host,
                                port=port,
                                protocol='http',
                                status='running',
                                version=server_info.get('version'),
                                capabilities=server_info.get('capabilities', []),
                                health_endpoint=server_info.get('health_endpoint'),
                                discovery_method='port_scan'
                            )
                            servers.append(server)
                    
                    # Test WebSocket connection
                    is_ws = await self._test_websocket_endpoint(host, port)
                    if is_ws:
                        server = MCPServerInfo(
                            server_id=f"ws_{host}_{port}",
                            name=f'mcp-ws-{port}',
                            host=host,
                            port=port,
                            protocol='websocket',
                            status='running',
                            discovery_method='port_scan'
                        )
                        servers.append(server)
                        
                except Exception:
                    continue
        
        return servers
    
    async def _test_http_endpoint(self, host: str, port: int) -> bool:
        """Testet HTTP-Endpoint"""
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=2)) as session:
                async with session.get(f'http://{host}:{port}/') as response:
                    return response.status < 500
        except:
            return False
    
    async def _test_websocket_endpoint(self, host: str, port: int) -> bool:
        """Testet WebSocket-Endpoint"""
        try:
            import websockets
            async with websockets.connect(f'ws://{host}:{port}/', timeout=2):
                return True
        except:
            return False
    
    async def _probe_http_server(self, host: str, port: int) -> Optional[Dict]:
        """Probt HTTP-Server für MCP-spezifische Endpoints"""
        
        common_endpoints = [
            '/',
            '/health',
            '/status', 
            '/info',
            '/version',
            '/mcp',
            '/api/health',
            '/api/info'
        ]
        
        server_info = {}
        
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=5)) as session:
                for endpoint in common_endpoints:
                    try:
                        async with session.get(f'http://{host}:{port}{endpoint}') as response:
                            if response.status == 200:
                                try:
                                    data = await response.json()
                                    server_info.update(data)
                                    
                                    # Store endpoint info
                                    if 'health' in endpoint:
                                        server_info['health_endpoint'] = endpoint
                                    
                                except:
                                    # Not JSON, try text
                                    text = await response.text()
                                    if 'mcp' in text.lower() or 'model context protocol' in text.lower():
                                        server_info['is_mcp'] = True
                                    
                    except:
                        continue
            
            return server_info if server_info else None
            
        except Exception:
            return None
    
    def _is_likely_mcp_server(self, server_info: Dict) -> bool:
        """Prüft ob Server wahrscheinlich ein MCP-Server ist"""
        
        mcp_indicators = [
            'mcp',
            'model context protocol',
            'claude',
            'anthropic',
            'tools',
            'resources',
            'prompts'
        ]
        
        # Check in various fields
        check_fields = ['name', 'description', 'server_name', 'service']
        
        info_text = json.dumps(server_info).lower()
        
        return any(indicator in info_text for indicator in mcp_indicators)
    
    async def _discover_by_docker_scan(self) -> List[MCPServerInfo]:
        """Erkennung durch Docker-Container-Scanning"""
        
        if not self.docker_client:
            return []
        
        servers = []
        
        try:
            containers = self.docker_client.containers.list(all=True)
            
            for container in containers:
                # Check if container looks like MCP server
                if self._is_mcp_container(container):
                    server = await self._create_server_from_container(container)
                    if server:
                        servers.append(server)
        
        except Exception as e:
            logger.error(f"Error scanning Docker containers: {e}")
        
        return servers
    
    def _is_mcp_container(self, container) -> bool:
        """Prüft ob Container ein MCP-Server ist"""
        
        # Check container name
        if any(keyword in container.name.lower() for keyword in ['mcp', 'claude', 'anthropic']):
            return True
        
        # Check image name
        if hasattr(container, 'image') and container.image.tags:
            image_name = ' '.join(container.image.tags).lower()
            if any(keyword in image_name for keyword in ['mcp', 'claude', 'anthropic']):
                return True
        
        # Check environment variables
        try:
            env_vars = container.attrs.get('Config', {}).get('Env', [])
            env_text = ' '.join(env_vars).lower()
            if 'mcp' in env_text or 'model_context_protocol' in env_text:
                return True
        except:
            pass
        
        return False
    
    async def _create_server_from_container(self, container) -> Optional[MCPServerInfo]:
        """Erstellt Server-Info aus Docker-Container"""
        
        try:
            # Get container info
            container.reload()
            
            # Extract port mappings
            ports = container.attrs.get('NetworkSettings', {}).get('Ports', {})
            port = None
            host_port = None
            
            for container_port, host_bindings in ports.items():
                if host_bindings:
                    port = int(container_port.split('/')[0])
                    host_port = int(host_bindings[0]['HostPort'])
                    break
            
            if not port:
                # Try to extract from exposed ports
                exposed_ports = container.attrs.get('Config', {}).get('ExposedPorts', {})
                if exposed_ports:
                    port = int(list(exposed_ports.keys())[0].split('/')[0])
            
            # Determine status
            status = 'running' if container.status == 'running' else 'stopped'
            
            server = MCPServerInfo(
                server_id=f"docker_{container.id[:12]}",
                name=container.name,
                host='localhost',
                port=host_port or port or 8000,
                protocol='http',
                status=status,
                container_id=container.id,
                container_name=container.name,
                image_name=container.image.tags[0] if container.image.tags else 'unknown',
                discovery_method='docker_scan'
            )
            
            return server
            
        except Exception as e:
            logger.debug(f"Error creating server from container: {e}")
            return None
    
    async def _discover_by_config_scan(self) -> List[MCPServerInfo]:
        """Erkennung durch Konfigurationsdatei-Scanning"""
        
        servers = []
        
        # Common config file locations
        config_locations = [
            '~/.config/mcp/',
            './config/',
            '/etc/mcp/',
            './mcp-servers/',
            '~/.mcp/',
            './servers.json',
            './mcp-config.json',
            './claude-config.json'
        ]
        
        for location in config_locations:
            expanded_path = Path(location).expanduser()
            
            if expanded_path.is_dir():
                # Scan directory for config files
                for config_file in expanded_path.glob('*.json'):
                    servers.extend(await self._parse_config_file(config_file))
                for config_file in expanded_path.glob('*.yaml'):
                    servers.extend(await self._parse_config_file(config_file))
            elif expanded_path.is_file():
                # Single config file
                servers.extend(await self._parse_config_file(expanded_path))
        
        return servers
    
    async def _parse_config_file(self, config_file: Path) -> List[MCPServerInfo]:
        """Parst Konfigurationsdatei für MCP-Server"""
        
        servers = []
        
        try:
            with open(config_file, 'r') as f:
                if config_file.suffix == '.json':
                    config = json.load(f)
                else:
                    config = yaml.safe_load(f)
            
            # Different config formats
            if 'mcpServers' in config:
                # Claude Desktop format
                for server_name, server_config in config['mcpServers'].items():
                    server = self._create_server_from_config(server_name, server_config, config_file)
                    if server:
                        servers.append(server)
            
            elif 'servers' in config:
                # Generic servers format
                for server_config in config['servers']:
                    server = self._create_server_from_config(
                        server_config.get('name', 'unknown'), 
                        server_config, 
                        config_file
                    )
                    if server:
                        servers.append(server)
            
            elif 'command' in config or 'url' in config:
                # Single server config
                server = self._create_server_from_config('main', config, config_file)
                if server:
                    servers.append(server)
                    
        except Exception as e:
            logger.debug(f"Error parsing config file {config_file}: {e}")
        
        return servers
    
    def _create_server_from_config(self, name: str, config: Dict, config_file: Path) -> Optional[MCPServerInfo]:
        """Erstellt Server-Info aus Konfiguration"""
        
        try:
            # Extract connection info
            if 'url' in config:
                # URL-based server
                url = urlparse(config['url'])
                host = url.hostname or 'localhost'
                port = url.port or (443 if url.scheme == 'https' else 80)
                protocol = url.scheme
            else:
                # Command-based server (local)
                host = 'localhost'
                port = config.get('port', 8000)
                protocol = 'http'
            
            # Extract executable path
            executable_path = None
            source_directory = None
            
            if 'command' in config:
                command = config['command']
                if isinstance(command, list):
                    executable_path = command[0]
                else:
                    executable_path = command.split()[0]
                
                # Try to find source directory
                exe_path = Path(executable_path)
                if exe_path.exists():
                    if exe_path.is_file():
                        source_directory = str(exe_path.parent)
                    else:
                        source_directory = str(exe_path)
            
            server = MCPServerInfo(
                server_id=f"config_{name}",
                name=name,
                host=host,
                port=port,
                protocol=protocol,
                status='unknown',
                executable_path=executable_path,
                source_directory=source_directory,
                config_file=str(config_file),
                discovery_method='config_file_scan'
            )
            
            return server
            
        except Exception as e:
            logger.debug(f"Error creating server from config: {e}")
            return None
    
    async def _discover_by_service_registry(self) -> List[MCPServerInfo]:
        """Erkennung durch Service Registry (Consul, etcd, etc.)"""
        
        # This would integrate with service discovery systems
        # For now, return empty list
        return []
    
    def _deduplicate_servers(self, servers: List[MCPServerInfo]) -> List[MCPServerInfo]:
        """Entfernt Duplikate und merged Informationen"""
        
        unique_servers = {}
        
        for server in servers:
            # Create key for deduplication
            key = f"{server.host}:{server.port}"
            
            if key in unique_servers:
                # Merge information
                existing = unique_servers[key]
                
                # Prefer more detailed information
                if server.pid and not existing.pid:
                    existing.pid = server.pid
                    existing.process_name = server.process_name
                    existing.command_line = server.command_line
                
                if server.container_id and not existing.container_id:
                    existing.container_id = server.container_id
                    existing.container_name = server.container_name
                    existing.image_name = server.image_name
                
                if server.source_directory and not existing.source_directory:
                    existing.source_directory = server.source_directory
                
                if server.config_file and not existing.config_file:
                    existing.config_file = server.config_file
                
                # Combine discovery methods
                if server.discovery_method not in existing.discovery_method:
                    existing.discovery_method += f", {server.discovery_method}"
                
            else:
                unique_servers[key] = server
        
        return list(unique_servers.values())
    
    async def _enhance_server_info(self, server: MCPServerInfo):
        """Erweitert Server-Informationen durch zusätzliche Probes"""
        
        try:
            # Update status by testing connection
            if server.status == 'unknown':
                is_alive = await self._test_server_connection(server)
                server.status = 'running' if is_alive else 'stopped'
            
            # Try to get version and capabilities
            if server.status == 'running':
                server_info = await self._get_server_info(server)
                if server_info:
                    server.version = server_info.get('version')
                    server.capabilities = server_info.get('capabilities', [])
            
            # Find log files
            if server.source_directory:
                log_files = await self._find_log_files(server.source_directory)
                server.log_files.extend(log_files)
            
            # Update last seen
            server.last_seen = datetime.now()
            
        except Exception as e:
            logger.debug(f"Error enhancing server info: {e}")
    
    async def _test_server_connection(self, server: MCPServerInfo) -> bool:
        """Testet Verbindung zum Server"""
        
        try:
            if server.protocol in ['http', 'https']:
                return await self._test_http_endpoint(server.host, server.port)
            elif server.protocol == 'websocket':
                return await self._test_websocket_endpoint(server.host, server.port)
            else:
                # Test raw TCP connection
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((server.host, server.port))
                sock.close()
                return result == 0
                
        except:
            return False
    
    async def _get_server_info(self, server: MCPServerInfo) -> Optional[Dict]:
        """Holt Server-Informationen über API"""
        
        if server.protocol in ['http', 'https']:
            return await self._probe_http_server(server.host, server.port)
        
        # For other protocols, return None for now
        return None
    
    async def _find_log_files(self, directory: str) -> List[str]:
        """Findet Log-Dateien im angegebenen Verzeichnis"""
        
        log_files = []
        
        try:
            dir_path = Path(directory)
            if not dir_path.exists():
                return log_files
            
            # Common log file patterns
            log_patterns = [
                '*.log',
                '*.out',
                'logs/*.log',
                'log/*.log',
                '**/application.log',
                '**/error.log',
                '**/server.log'
            ]
            
            for pattern in log_patterns:
                for log_file in dir_path.glob(pattern):
                    if log_file.is_file():
                        log_files.append(str(log_file))
            
        except Exception as e:
            logger.debug(f"Error finding log files: {e}")
        
        return log_files

# ============================================================================
# AUTO-CONFIGURATION GENERATOR  
# ============================================================================

class MCPAutoConfigurator:
    """Automatische Konfigurationsgenerierung für entdeckte MCP-Server"""
    
    def __init__(self, discovered_servers: List[MCPServerInfo]):
        self.servers = discovered_servers
    
    async def generate_monitoring_config(self) -> Dict[str, Any]:
        """Generiert vollständige Monitoring-Konfiguration für alle Server"""
        
        config = {
            'server_type': 'mcp_multi',
            'monitoring_interval': 30,
            'learning_enabled': True,
            'auto_remediation': True,
            
            'mcp_servers': {},
            'code_analysis': {
                'enabled': True,
                'source_directories': [],
                'auto_fix': False,
                'confidence_threshold': 0.7
            },
            
            'plugins': {
                'metrics_collectors': [],
                'problem_detectors': [],
                'remediators': []
            }
        }
        
        # Configure each discovered server
        for server in self.servers:
            server_config = await self._generate_server_config(server)
            config['mcp_servers'][server.server_id] = server_config
            
            # Add source directories for code analysis
            if server.source_directory:
                if server.source_directory not in config['code_analysis']['source_directories']:
                    config['code_analysis']['source_directories'].append(server.source_directory)
            
            # Add log files to monitoring
            if server.log_files:
                log_collector_config = self._find_or_create_log_collector(config)
                for log_file in server.log_files:
                    log_collector_config['config']['log_files'].append({
                        'path': log_file,
                        'type': 'mcp_server',
                        'server_id': server.server_id
                    })
        
        # Add standard plugins
        self._add_standard_plugins(config)
        
        return config
    
    async def _generate_server_config(self, server: MCPServerInfo) -> Dict[str, Any]:
        """Generiert Konfiguration für einzelnen Server"""
        
        return {
            'name': server.name,
            'host': server.host,
            'port': server.port,
            'protocol': server.protocol,
            'health_endpoint': server.health_endpoint or '/health',
            'metrics_endpoint': server.metrics_endpoint or '/metrics',
            
            # Monitoring configuration
            'monitor_health': True,
            'monitor_performance': True,
            'monitor_logs': bool(server.log_files),
            
            # Code analysis
            'source_directory': server.source_directory,
            'executable_path': server.executable_path,
            'config_file': server.config_file,
            
            # Container info (if applicable)
            'container_id': server.container_id,
            'container_name': server.container_name,
            
            # Process info (if applicable) 
            'pid': server.pid,
            'process_name': server.process_name,
            
            # Discovery metadata
            'discovery_method': server.discovery_method,
            'discovered_at': server.discovered_at.isoformat(),
            'last_seen': server.last_seen.isoformat()
        }
    
    def _find_or_create_log_collector(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Findet oder erstellt Log-Collector-Konfiguration"""
        
        for collector in config['plugins']['metrics_collectors']:
            if collector['name'] == 'log_file_collector':
                return collector
        
        # Create new log collector
        log_collector = {
            'name': 'log_file_collector',
            'config': {
                'log_files': []
            }
        }
        
        config['plugins']['metrics_collectors'].append(log_collector)
        return log_collector
    
    def _add_standard_plugins(self, config: Dict[str, Any]):
        """Fügt Standard-Plugins hinzu"""
        
        # System metrics collector
        if not any(p['name'] == 'system_metrics_collector' 
                  for p in config['plugins']['metrics_collectors']):
            config['plugins']['metrics_collectors'].append({
                'name': 'system_metrics_collector',
                'config': {}
            })
        
        # MCP-specific metrics collector
        config['plugins']['metrics_collectors'].append({
            'name': 'mcp_metrics_collector',
            'config': {
                'servers': list(config['mcp_servers'].keys())
            }
        })
        
        # Standard detectors
        config['plugins']['problem_detectors'].extend([
            {
                'name': 'threshold_detector',
                'config': {
                    'thresholds': {
                        'cpu_usage': {'warning': 80, 'critical': 95},
                        'memory_usage': {'warning': 85, 'critical': 95},
                        'mcp_response_time': {'warning': 2.0, 'critical': 5.0},
                        'mcp_error_rate': {'warning': 0.05, 'critical': 0.1}
                    }
                }